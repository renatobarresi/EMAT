/*
 * W25Qx_module.cpp
 *
 *  Created on: Apr 5, 2023
 *      Author: renatobarresi
 */
#include "W25Qx_module.h"

/* constexpr */
constexpr uint8_t CMD_WRITE_ENABLE       = 0x06;
constexpr uint8_t CMD_WRITE_DISABLE      = 0x04;
constexpr uint8_t CMD_READ_STATUS_REG    = 0x05;
constexpr uint8_t CMD_WRITE_STATUS_REG   = 0x01;
constexpr uint8_t CMD_CHIP_ERASE         = 0xC7;
constexpr uint8_t CMD_SECTOR_ERASE       = 0x20;
constexpr uint8_t CMD_BLOCK_ERASE        = 0xD8; // or 0x52 for 32KB block erase
constexpr uint8_t CMD_PAGE_PROGRAM       = 0x02;
constexpr uint8_t CMD_READ_DATA          = 0x03;

/* Constructor */
W25Q64::W25Q64(SPI_HandleTypeDef *hspi, GPIO_TypeDef *cs_gpio_port, uint16_t cs_pin)
	: mySPIPort(hspi, cs_pin, cs_gpio_port)
{
	this->hspi = hspi;
	this->csPin = cs_pin;
	this->csGPIOPort = cs_gpio_port;
}

/* Public methods */
HAL_StatusTypeDef W25Q64::init()
{
	return mySPIPort.init();
}

void W25Q64::write_enable()
{
	cs_select();
	mySPIPort.transmit(&CMD_WRITE_ENABLE, 1);
	cs_deselect();
}

void W25Q64::write_disable()
{

}

uint8_t W25Q64::read_status_register()
{

}
void W25Q64::write_status_register(uint8_t status)
{

}
void W25Q64::chip_erase()
{

}

void W25Q64::sector_erase(uint32_t addr)
{

}

void W25Q64::block_erase(uint32_t addr)
{

}

void W25Q64::page_program(uint32_t addr, uint8_t *data, uint16_t size)
{

}

void W25Q64::read_data(uint32_t addr, uint8_t *data, uint16_t size)
{

}

void W25Q64::wait_until_ready()
{

}

/* Private methods */
void W25Q64::cs_select()
{
	mySPIPort.csHigh();
}
void W25Q64::cs_deselect()
{
	mySPIPort.csLow();
}
