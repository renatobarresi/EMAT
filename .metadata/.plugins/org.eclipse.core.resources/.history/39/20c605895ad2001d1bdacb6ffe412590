/*
 * serialPort_module.cpp
 *
 *  Created on: Mar 22, 2023
 *      Author: renatobarresi
 */

#include "serialPort_module.h"
#include <cstring>

/* DMA related objects TODO: Abstract it */
extern DMA_HandleTypeDef hdma_usart3_rx;
extern DMA_HandleTypeDef hdma_usart3_tx;

#define RxBuf_SIZE 512
#define MainBuf_SIZE 2048

uint8_t RxBuf[RxBuf_SIZE];
uint8_t MainBuf[MainBuf_SIZE];

uint16_t oldPos = 0;
uint16_t newPos = 0;

uint8_t isOK = 0;

void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
	if (huart->Instance == USART3)
	{
		oldPos = newPos;  // Update the last position before copying new data

		/* If the data in large and it is about to exceed the buffer size, we have to route it to the start of the buffer
		 * This is to maintain the circular buffer
		 * The old data in the main buffer will be overlapped
		 */
		if (oldPos+Size > MainBuf_SIZE)  // If the current position + new data size is greater than the main buffer
		{
			uint16_t datatocopy = MainBuf_SIZE-oldPos;  // find out how much space is left in the main buffer
			memcpy ((uint8_t *)MainBuf+oldPos, RxBuf, datatocopy);  // copy data in that remaining space

			oldPos = 0;  // point to the start of the buffer
			memcpy ((uint8_t *)MainBuf, (uint8_t *)RxBuf+datatocopy, (Size-datatocopy));  // copy the remaining data
			newPos = (Size-datatocopy);  // update the position
		}

		/* if the current position + new data size is less than the main buffer
		 * we will simply copy the data into the buffer and update the position
		 */
		else
		{
			memcpy ((uint8_t *)MainBuf+oldPos, RxBuf, Size);
			newPos = Size+oldPos;
		}

		/* start the DMA again */
		HAL_UARTEx_ReceiveToIdle_DMA(huart, (uint8_t *) RxBuf, RxBuf_SIZE);
		__HAL_DMA_DISABLE_IT(&hdma_usart3_rx, DMA_IT_HT);
	}
}

/* Private methods */
void serialPort::initDMAPeripheral()
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
  /* DMA1_Stream3_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream3_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream3_IRQn);
}

bool serialPort::initUartPeripheral(UART_HandleTypeDef *uartHandler, USART_TypeDef *instance, uint32_t baudrate)
{
	// fill the UART_HandleTypeDef structure and Init the USART peripheral
	uartHandler->Instance = instance;
	uartHandler->Init.BaudRate = baudrate;
	uartHandler->Init.WordLength = UART_WORDLENGTH_8B;
	uartHandler->Init.StopBits = UART_STOPBITS_1;
	uartHandler->Init.Parity = UART_PARITY_NONE;
	uartHandler->Init.Mode = UART_MODE_TX_RX;
	uartHandler->Init.HwFlowCtl = UART_HWCONTROL_NONE;
	uartHandler->Init.OverSampling = UART_OVERSAMPLING_16;

	if (HAL_UART_Init(uartHandler) != HAL_OK)
	{
		return false;
	}

	// Start the DMA IDLE line
	if (HAL_OK != HAL_UARTEx_ReceiveToIdle_DMA(uartHandler, RxBuf, RxBuf_SIZE))
	{
		return false;
	}
	__HAL_DMA_DISABLE_IT(&hdma_usart3_rx, DMA_IT_HT);
	return true;
}

/* Constructor */
/**
 * @brief Constructor for the serialPort class
 * @param instance: Pointer to the USART_TypeDef structure
 * @param uartHandler: Pointer to the UART_HandleTypeDef structure
 * @param baudrate: Baud rate of the USART peripheral
 */
serialPort::serialPort(USART_TypeDef *instance, UART_HandleTypeDef *uartHandler, uint32_t baudrate)
{
	this->instance = instance;
	this->uartHandler = uartHandler;
	this->baudrate = baudrate;
}


/* Public Methods */
/**
 * @brief Initializes the serial port
 * @return true if successful, false otherwise
 */
bool serialPort::init()
{
	initDMAPeripheral();
	return initUartPeripheral(this->uartHandler, this->instance, this->baudrate);
}

/**
 * @brief Write a string to the serial port
 * @param pBuff: String to be sent
 * @return true if successful, false otherwise
 */
bool serialPort::write(const std::string &pBuff)
{
	// Calculate string width
	uint32_t buffLenght = pBuff.length();

	// Convert string to char TODO: check that new worked
	char *charArray = new char[buffLenght + 1];
	strcpy(charArray, pBuff.c_str());

	// Transmit buffer via UART port
	HAL_UART_Transmit_DMA(this->uartHandler, (const uint8_t *)charArray, buffLenght);
	HAL_Delay(10);

	// Free memory
	delete[] charArray;

	return true;
}

/**
 * @brief Read data from the serial buffer
 * @return A std::string containing the data from the buffer
 */
std::string serialPort::read()
{
    //std::lock_guard<std::mutex> lock(bufferMutex); // Optional: use a mutex for thread safety

    std::string receivedData = "";

    // Search for the newline character as a delimiter
    for (uint16_t i = oldPos; i < newPos; ++i) {
        if (MainBuf[i] == '\r') {
            // Copy data from MainBuf to a new string
            receivedData = std::string(reinterpret_cast<char*>(MainBuf) + oldPos, i - oldPos + 1);

            // Clear the part of MainBuf that was read
            std::memset(MainBuf + oldPos, 0, i - oldPos + 1);

            // Update oldPos
            oldPos = i + 1;

            break;
        }
    }

    return receivedData;
}
